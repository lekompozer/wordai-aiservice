# Order Management Intents - Implementation Analysis
# Ph√¢n T√≠ch Tri·ªÉn Khai C√°c Intent Qu·∫£n L√Ω ƒê∆°n H√†ng

## üìã T·ªïng Quan

T√†i li·ªáu n√†y ph√¢n t√≠ch chi ti·∫øt vi·ªác tri·ªÉn khai 3 intents qu·∫£n l√Ω ƒë∆°n h√†ng trong AI chatbot system:
1. **PLACE_ORDER** (ƒë√£ c√≥ partial implementation)
2. **UPDATE_ORDER** (c·∫ßn implement m·ªõi)
3. **CHECK_QUANTITY** (c·∫ßn implement m·ªõi)

## üîç Current System Analysis

### ‚úÖ Hi·ªán T·∫°i ƒê√£ C√≥ (PLACE_ORDER)

#### **1. Models & Enums**
```python
# src/models/unified_models.py
class ChatIntent(str, Enum):
    INFORMATION = "information"
    SALES_INQUIRY = "sales_inquiry"
    SUPPORT = "support"
    GENERAL_CHAT = "general_chat"
    PLACE_ORDER = "place_order"  # ‚úÖ ƒê√£ c√≥
```

#### **2. Service Implementation**
```python
# src/services/unified_chat_service.py - ƒê√£ c√≥ c√°c methods:
‚úÖ _is_order_confirmation_complete()
‚úÖ _extract_order_data_from_conversation()
‚úÖ _send_order_created_webhook()
‚úÖ _calculate_order_totals()
```

#### **3. AI Prompt Support**
- ‚úÖ ƒê√£ update prompt h·ªó tr·ª£ 5 intents bao g·ªìm PLACE_ORDER
- ‚úÖ C√≥ workflow thu th·∫≠p th√¥ng tin multi-turn conversation
- ‚úÖ C√≥ order completion detection

#### **4. Webhook Integration**
- ‚úÖ Endpoint: `POST /api/webhooks/orders/ai` (t·∫°o ƒë∆°n h√†ng m·ªõi)
- ‚úÖ JSON payload structure ƒë√£ ƒë·ªãnh nghƒ©a
- ‚úÖ Backend response handling

### ‚ùå Thi·∫øu & C·∫ßn Implement

#### **1. Missing Intents**
```python
# C·∫ßn th√™m v√†o ChatIntent enum:
UPDATE_ORDER = "update_order"      # C·∫≠p nh·∫≠t ƒë∆°n h√†ng
CHECK_QUANTITY = "check_quantity"  # Ki·ªÉm tra t·ªìn kho
```

#### **2. Missing Service Methods**
- ‚ùå Order update detection & processing
- ‚ùå Quantity check request processing
- ‚ùå Order code validation
- ‚ùå Update data extraction from conversation

#### **3. Missing Webhook Endpoints**
- ‚ùå `PUT /api/webhooks/orders/{orderCode}/ai` (c·∫≠p nh·∫≠t)
- ‚ùå `POST /api/webhooks/orders/check-quantity/ai` (ki·ªÉm tra)

## üéØ Implementation Plan

### Phase 1: Models & Enums Update

#### **1.1 Update ChatIntent Enum**
```python
# File: src/models/unified_models.py
class ChatIntent(str, Enum):
    INFORMATION = "information"
    SALES_INQUIRY = "sales_inquiry"
    SUPPORT = "support"
    GENERAL_CHAT = "general_chat"
    PLACE_ORDER = "place_order"     # ‚úÖ Existing
    UPDATE_ORDER = "update_order"   # üÜï New
    CHECK_QUANTITY = "check_quantity" # üÜï New
```

#### **1.2 Create New Model Classes**
```python
# File: src/models/order_models.py (new file)
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime

class OrderUpdateRequest(BaseModel):
    """Model cho update order request"""
    order_code: str = Field(..., description="M√£ ƒë∆°n h√†ng c·∫ßn update")
    products: Optional[List[Dict]] = Field(None, description="S·∫£n ph·∫©m c·∫ßn thay ƒë·ªïi")
    customer: Optional[Dict] = Field(None, description="Th√¥ng tin kh√°ch h√†ng update")
    payment: Optional[Dict] = Field(None, description="Th√¥ng tin thanh to√°n update")
    delivery: Optional[Dict] = Field(None, description="Th√¥ng tin giao h√†ng update")
    notes: Optional[str] = Field(None, description="Ghi ch√∫ thay ƒë·ªïi")

class QuantityCheckRequest(BaseModel):
    """Model cho quantity check request"""
    products: List[Dict] = Field(..., description="Danh s√°ch s·∫£n ph·∫©m c·∫ßn check")
    customer_contact: Dict = Field(..., description="Th√¥ng tin li√™n h·ªá kh√°ch h√†ng")
    contact_method: str = Field(..., description="Ph∆∞∆°ng th·ª©c li√™n h·ªá: email/sms")
    notes: Optional[str] = Field(None, description="Ghi ch√∫ y√™u c·∫ßu")
```

### Phase 2: AI Prompt Enhancement

#### **2.1 Enhanced System Prompt**
```python
# File: src/services/unified_chat_service.py
def _build_unified_prompt_with_intent(self, ...):
    system_prompt = f"""
B·∫†N C√ì 7 CH·ª®C NƒÇNG CH√çNH:
1. INFORMATION: Cung c·∫•p th√¥ng tin c√¥ng ty/s·∫£n ph·∫©m/d·ªãch v·ª•
2. SALES_INQUIRY: T∆∞ v·∫•n v√† h·ªó tr·ª£ quy·∫øt ƒë·ªãnh mua h√†ng
3. SUPPORT: H·ªó tr·ª£ k·ªπ thu·∫≠t v√† x·ª≠ l√Ω khi·∫øu n·∫°i
4. GENERAL_CHAT: Tr√≤ chuy·ªán th√¥ng th∆∞·ªùng v√† t∆∞∆°ng t√°c
5. PLACE_ORDER: Thu th·∫≠p th√¥ng tin ƒë·ªÉ t·∫°o ƒë∆°n h√†ng m·ªõi
6. UPDATE_ORDER: Thu th·∫≠p th√¥ng tin ƒë·ªÉ c·∫≠p nh·∫≠t ƒë∆°n h√†ng hi·ªán c√≥
7. CHECK_QUANTITY: Thu th·∫≠p th√¥ng tin ƒë·ªÉ ki·ªÉm tra t·ªìn kho/kh·∫£ d·ª•ng

QUAN TR·ªåNG cho ORDER INTENTS:

UPDATE_ORDER Flow:
- Y√™u c·∫ßu m√£ ƒë∆°n h√†ng (order code) t·ª´ email kh√°ch h√†ng
- Thu th·∫≠p th√¥ng tin c·∫ßn thay ƒë·ªïi: s·∫£n ph·∫©m, s·ªë l∆∞·ª£ng, th√¥ng tin kh√°ch h√†ng, thanh to√°n, giao h√†ng
- X√°c nh·∫≠n thay ƒë·ªïi tr∆∞·ªõc khi g·ª≠i webhook

CHECK_QUANTITY Flow:
- Thu th·∫≠p danh s√°ch s·∫£n ph·∫©m c·∫ßn ki·ªÉm tra t·ªìn kho
- Thu th·∫≠p th√¥ng tin li√™n h·ªá: t√™n, email/sdt
- Ch·ªçn ph∆∞∆°ng th·ª©c th√¥ng b√°o: email ho·∫∑c SMS
- Th√¥ng b√°o kh√°ch h√†ng s·∫Ω ƒë∆∞·ª£c li√™n h·ªá v·ªÅ k·∫øt qu·∫£
"""
```

#### **2.2 Intent Detection Patterns**
```python
# Enhanced intent detection patterns
UPDATE_ORDER_PATTERNS = [
    "c·∫≠p nh·∫≠t ƒë∆°n h√†ng", "thay ƒë·ªïi ƒë∆°n h√†ng", "s·ª≠a ƒë∆°n h√†ng",
    "update order", "change order", "modify order",
    "c√≥ m√£ ƒë∆°n h√†ng", "order code", "m√£ ORD"
]

CHECK_QUANTITY_PATTERNS = [
    "ki·ªÉm tra t·ªìn kho", "c√≤n h√†ng kh√¥ng", "check quantity",
    "available stock", "h√†ng c√≥ s·∫µn", "kh·∫£ d·ª•ng",
    "s·ªë l∆∞·ª£ng h√†ng", "inventory check"
]
```

### Phase 3: Service Methods Implementation

#### **3.1 Order Update Methods**
```python
# File: src/services/unified_chat_service.py

async def _is_update_order_confirmation_complete(
    self,
    parsed_response: Dict[str, Any],
    user_message: str
) -> bool:
    """Ki·ªÉm tra user ƒë√£ confirm update order v√† c√≥ ƒë·ªß th√¥ng tin"""
    try:
        # Check confirmation keywords
        confirmation_keywords = [
            "ƒë·ªìng √Ω c·∫≠p nh·∫≠t", "x√°c nh·∫≠n thay ƒë·ªïi", "ok", "ƒë∆∞·ª£c",
            "confirm update", "yes", "agree to change"
        ]

        user_message_lower = user_message.lower()
        has_confirmation = any(keyword in user_message_lower for keyword in confirmation_keywords)

        # Check AI mentions update completion
        final_answer = parsed_response.get("final_answer", "").lower()
        update_completion_phrases = [
            "c·∫≠p nh·∫≠t ƒë∆°n h√†ng th√†nh c√¥ng", "order updated successfully",
            "thay ƒë·ªïi ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n", "ƒë√£ c·∫≠p nh·∫≠t th√¥ng tin"
        ]

        has_update_completion = any(phrase in final_answer for phrase in update_completion_phrases)

        logger.info(f"üîÑ [UPDATE_CHECK] User confirmation: {has_confirmation}")
        logger.info(f"üîÑ [UPDATE_CHECK] AI mentions completion: {has_update_completion}")

        return has_confirmation and has_update_completion

    except Exception as e:
        logger.error(f"‚ùå [UPDATE_CHECK] Error: {e}")
        return False

async def _extract_update_order_data_from_conversation(
    self,
    request: UnifiedChatRequest,
    parsed_response: Dict[str, Any]
) -> Optional[Dict[str, Any]]:
    """Extract order update information t·ª´ conversation history"""
    try:
        # Get conversation history
        user_id = request.user_info.user_id if request.user_info else None
        device_id = request.user_info.device_id if request.user_info else None
        session_id = request.session_id

        conversation_history = []
        if self.conversation_manager:
            history = self.conversation_manager.get_optimized_messages_for_frontend(
                user_id=user_id,
                device_id=device_id,
                session_id=session_id,
                rag_context="",
                current_query=""
            )
            conversation_history = [f"{msg.role}: {msg.content}" for msg in history]

        # Add current exchange
        conversation_history.append(f"user: {request.message}")
        conversation_history.append(f"assistant: {parsed_response.get('final_answer', '')}")

        conversation_text = "\n".join(conversation_history[-10:])

        # AI extraction prompt for order updates
        extraction_prompt = f"""
T·ª´ cu·ªôc h·ªôi tho·∫°i sau, tr√≠ch xu·∫•t th√¥ng tin C·∫¨P NH·∫¨T ƒë∆°n h√†ng th√†nh JSON format:

{conversation_text}

Tr·∫£ v·ªÅ JSON v·ªõi format:
{{
  "order_code": "ORD20250817001",
  "changes": {{
    "products": [
      {{
        "name": "t√™n s·∫£n ph·∫©m",
        "quantity": s·ªë_l∆∞·ª£ng_m·ªõi,
        "notes": "ghi ch√∫ thay ƒë·ªïi"
      }}
    ],
    "customer": {{
      "name": "t√™n m·ªõi",
      "phone": "sdt m·ªõi",
      "email": "email m·ªõi",
      "address": "ƒë·ªãa ch·ªâ m·ªõi"
    }},
    "payment": {{
      "method": "ph∆∞∆°ng th·ª©c thanh to√°n m·ªõi",
      "timing": "th·ªùi ƒëi·ªÉm thanh to√°n m·ªõi"
    }},
    "delivery": {{
      "method": "ph∆∞∆°ng th·ª©c giao h√†ng m·ªõi",
      "address": "ƒë·ªãa ch·ªâ giao h√†ng m·ªõi",
      "phone": "sdt nh·∫≠n h√†ng m·ªõi",
      "notes": "ghi ch√∫ giao h√†ng m·ªõi"
    }}
  }},
  "update_reason": "l√Ω do thay ƒë·ªïi",
  "notes": "ghi ch√∫ kh√°c"
}}

CH·ªà tr·∫£ v·ªÅ nh·ªØng tr∆∞·ªùng c√≥ thay ƒë·ªïi. N·∫øu kh√¥ng c√≥ thay ƒë·ªïi th√¨ kh√¥ng tr·∫£ v·ªÅ tr∆∞·ªùng ƒë√≥.
Ch·ªâ tr·∫£ v·ªÅ JSON, kh√¥ng c√≥ text kh√°c.
"""

        # Call AI to extract update data
        extraction_response = await self.ai_manager.stream_response(
            question=extraction_prompt,
            session_id=session_id,
            provider="cerebras"
        )

        full_extraction = ""
        async for chunk in extraction_response:
            full_extraction += chunk

        # Parse JSON from AI response
        json_match = re.search(r'\{.*\}', full_extraction, re.DOTALL)
        if json_match:
            update_data = json.loads(json_match.group(0))
            logger.info("üîÑ [UPDATE_EXTRACTION] Successfully extracted update data")
            return update_data
        else:
            logger.warning("üîÑ [UPDATE_EXTRACTION] No valid JSON found")
            return None

    except Exception as e:
        logger.error(f"‚ùå [UPDATE_EXTRACTION] Failed: {e}")
        return None

async def _send_update_order_webhook(
    self,
    request: UnifiedChatRequest,
    update_data: Dict[str, Any],
    processing_start_time: float
) -> bool:
    """Send order update webhook to backend"""
    try:
        import os
        import httpx

        order_code = update_data.get("order_code")
        if not order_code:
            logger.error("‚ùå [UPDATE_WEBHOOK] Missing order_code")
            return False

        # Build webhook payload for order update
        webhook_payload = {
            "companyId": request.company_id,
            "timestamp": datetime.now().isoformat(),
            "data": {
                "orderCode": order_code,
                "conversationId": getattr(request, "conversation_id", request.session_id),
                "sessionId": request.session_id,
                "userId": request.user_info.user_id if request.user_info else None,

                # Changes data
                "changes": update_data.get("changes", {}),
                "updateReason": update_data.get("update_reason", "Customer requested change"),
                "notes": update_data.get("notes", ""),

                # Channel Information
                "channel": {
                    "type": request.channel.value if request.channel else "chatdemo",
                    "pluginId": request.plugin_id,
                    "customerDomain": request.customer_domain
                },

                # Metadata
                "metadata": {
                    "source": "ai_conversation",
                    "aiModel": "qwen-3-235b-a22b-instruct-2507",
                    "processingTime": int((time.time() - processing_start_time) * 1000) if processing_start_time else 0,
                    "updatedAt": datetime.now().isoformat()
                }
            }
        }

        # Send webhook
        backend_url = os.getenv("BACKEND_WEBHOOK_URL", "http://localhost:8001")
        endpoint = f"{backend_url}/api/webhooks/orders/{order_code}/ai"

        webhook_secret = os.getenv("AI_WEBHOOK_SECRET", "ai-webhook-secret")
        headers = {
            "Content-Type": "application/json",
            "x-webhook-secret": webhook_secret,
            "User-Agent": "Agent8x-AI-Service/1.0"
        }

        async with httpx.AsyncClient() as client:
            response = await client.put(
                endpoint,
                json=webhook_payload,
                headers=headers,
                timeout=30.0
            )

            if response.status_code == 200:
                logger.info(f"‚úÖ [UPDATE_WEBHOOK] Successfully sent for {order_code}")
                return True
            else:
                logger.error(f"‚ùå [UPDATE_WEBHOOK] Backend returned {response.status_code}: {response.text}")
                return False

    except Exception as e:
        logger.error(f"‚ùå [UPDATE_WEBHOOK] Failed: {e}")
        return False
```

#### **3.2 Quantity Check Methods**
```python
async def _is_quantity_check_confirmation_complete(
    self,
    parsed_response: Dict[str, Any],
    user_message: str
) -> bool:
    """Ki·ªÉm tra user ƒë√£ confirm quantity check request"""
    try:
        confirmation_keywords = [
            "ƒë·ªìng √Ω ki·ªÉm tra", "ok ki·ªÉm tra", "x√°c nh·∫≠n check",
            "confirm check", "yes check", "check gi√∫p t√¥i"
        ]

        user_message_lower = user_message.lower()
        has_confirmation = any(keyword in user_message_lower for keyword in confirmation_keywords)

        # Check AI mentions check request completion
        final_answer = parsed_response.get("final_answer", "").lower()
        check_completion_phrases = [
            "y√™u c·∫ßu ki·ªÉm tra ƒë√£ ƒë∆∞·ª£c g·ª≠i", "s·∫Ω ki·ªÉm tra v√† th√¥ng b√°o",
            "request sent successfully", "will check and notify"
        ]

        has_check_completion = any(phrase in final_answer for phrase in check_completion_phrases)

        logger.info(f"üìã [QUANTITY_CHECK] User confirmation: {has_confirmation}")
        logger.info(f"üìã [QUANTITY_CHECK] AI mentions completion: {has_check_completion}")

        return has_confirmation and has_check_completion

    except Exception as e:
        logger.error(f"‚ùå [QUANTITY_CHECK] Error: {e}")
        return False

async def _extract_quantity_check_data_from_conversation(
    self,
    request: UnifiedChatRequest,
    parsed_response: Dict[str, Any]
) -> Optional[Dict[str, Any]]:
    """Extract quantity check information t·ª´ conversation"""
    try:
        # Get conversation history
        user_id = request.user_info.user_id if request.user_info else None
        device_id = request.user_info.device_id if request.user_info else None
        session_id = request.session_id

        conversation_history = []
        if self.conversation_manager:
            history = self.conversation_manager.get_optimized_messages_for_frontend(
                user_id=user_id,
                device_id=device_id,
                session_id=session_id,
                rag_context="",
                current_query=""
            )
            conversation_history = [f"{msg.role}: {msg.content}" for msg in history]

        conversation_history.append(f"user: {request.message}")
        conversation_history.append(f"assistant: {parsed_response.get('final_answer', '')}")

        conversation_text = "\n".join(conversation_history[-10:])

        # AI extraction prompt for quantity checks
        extraction_prompt = f"""
T·ª´ cu·ªôc h·ªôi tho·∫°i sau, tr√≠ch xu·∫•t th√¥ng tin KI·ªÇM TRA T·ªíN KHO th√†nh JSON format:

{conversation_text}

Tr·∫£ v·ªÅ JSON v·ªõi format:
{{
  "products": [
    {{
      "name": "t√™n s·∫£n ph·∫©m",
      "quantity_needed": s·ªë_l∆∞·ª£ng_c·∫ßn,
      "specifications": "th√¥ng s·ªë k·ªπ thu·∫≠t n·∫øu c√≥"
    }}
  ],
  "customer_contact": {{
    "name": "t√™n kh√°ch h√†ng",
    "phone": "s·ªë ƒëi·ªán tho·∫°i",
    "email": "email"
  }},
  "contact_method": "email ho·∫∑c sms",
  "urgency": "normal ho·∫∑c urgent",
  "notes": "ghi ch√∫ y√™u c·∫ßu ki·ªÉm tra"
}}

Ch·ªâ tr·∫£ v·ªÅ JSON, kh√¥ng c√≥ text kh√°c.
"""

        # Call AI to extract quantity check data
        extraction_response = await self.ai_manager.stream_response(
            question=extraction_prompt,
            session_id=session_id,
            provider="cerebras"
        )

        full_extraction = ""
        async for chunk in extraction_response:
            full_extraction += chunk

        # Parse JSON from AI response
        json_match = re.search(r'\{.*\}', full_extraction, re.DOTALL)
        if json_match:
            check_data = json.loads(json_match.group(0))
            logger.info("üìã [QUANTITY_EXTRACTION] Successfully extracted check data")
            return check_data
        else:
            logger.warning("üìã [QUANTITY_EXTRACTION] No valid JSON found")
            return None

    except Exception as e:
        logger.error(f"‚ùå [QUANTITY_EXTRACTION] Failed: {e}")
        return None

async def _send_quantity_check_webhook(
    self,
    request: UnifiedChatRequest,
    check_data: Dict[str, Any],
    processing_start_time: float
) -> bool:
    """Send quantity check webhook to backend"""
    try:
        import os
        import httpx

        # Build webhook payload for quantity check
        webhook_payload = {
            "companyId": request.company_id,
            "timestamp": datetime.now().isoformat(),
            "data": {
                "conversationId": getattr(request, "conversation_id", request.session_id),
                "sessionId": request.session_id,
                "userId": request.user_info.user_id if request.user_info else None,

                # Check request data
                "products": check_data.get("products", []),
                "customer_contact": check_data.get("customer_contact", {}),
                "contact_method": check_data.get("contact_method", "email"),
                "urgency": check_data.get("urgency", "normal"),
                "notes": check_data.get("notes", ""),

                # Channel Information
                "channel": {
                    "type": request.channel.value if request.channel else "chatdemo",
                    "pluginId": request.plugin_id,
                    "customerDomain": request.customer_domain
                },

                # Metadata
                "metadata": {
                    "source": "ai_conversation",
                    "aiModel": "qwen-3-235b-a22b-instruct-2507",
                    "processingTime": int((time.time() - processing_start_time) * 1000) if processing_start_time else 0,
                    "requestedAt": datetime.now().isoformat()
                }
            }
        }

        # Send webhook
        backend_url = os.getenv("BACKEND_WEBHOOK_URL", "http://localhost:8001")
        endpoint = f"{backend_url}/api/webhooks/orders/check-quantity/ai"

        webhook_secret = os.getenv("AI_WEBHOOK_SECRET", "ai-webhook-secret")
        headers = {
            "Content-Type": "application/json",
            "x-webhook-secret": webhook_secret,
            "User-Agent": "Agent8x-AI-Service/1.0"
        }

        async with httpx.AsyncClient() as client:
            response = await client.post(
                endpoint,
                json=webhook_payload,
                headers=headers,
                timeout=30.0
            )

            if response.status_code == 200:
                logger.info(f"‚úÖ [QUANTITY_WEBHOOK] Successfully sent quantity check request")
                return True
            else:
                logger.error(f"‚ùå [QUANTITY_WEBHOOK] Backend returned {response.status_code}: {response.text}")
                return False

    except Exception as e:
        logger.error(f"‚ùå [QUANTITY_WEBHOOK] Failed: {e}")
        return False
```

### Phase 4: Integration into Main Flow

#### **4.1 Enhanced _send_response_to_backend Method**
```python
# File: src/services/unified_chat_service.py - Update existing method

async def _send_response_to_backend(
    self,
    request: UnifiedChatRequest,
    ai_response: str,
    channel: ChannelType,
    parsed_response: Dict[str, Any] = None,
    processing_start_time: float = None,
):
    try:
        # ... existing code ...

        # üÜï Enhanced order intent processing
        detected_intent = parsed_response.get("thinking", {}).get("intent")

        # PLACE_ORDER handling (existing)
        if detected_intent == "place_order":
            if self._is_order_confirmation_complete(parsed_response, request.message):
                order_data = await self._extract_order_data_from_conversation(request, parsed_response)
                if order_data:
                    webhook_sent = await self._send_order_created_webhook(request, order_data, processing_start_time)
                    if webhook_sent:
                        logger.info("‚úÖ [ORDER] Successfully processed and sent webhook")

        # üÜï UPDATE_ORDER handling (new)
        elif detected_intent == "update_order":
            if self._is_update_order_confirmation_complete(parsed_response, request.message):
                update_data = await self._extract_update_order_data_from_conversation(request, parsed_response)
                if update_data:
                    webhook_sent = await self._send_update_order_webhook(request, update_data, processing_start_time)
                    if webhook_sent:
                        logger.info("‚úÖ [UPDATE_ORDER] Successfully processed and sent webhook")

        # üÜï CHECK_QUANTITY handling (new)
        elif detected_intent == "check_quantity":
            if self._is_quantity_check_confirmation_complete(parsed_response, request.message):
                check_data = await self._extract_quantity_check_data_from_conversation(request, parsed_response)
                if check_data:
                    webhook_sent = await self._send_quantity_check_webhook(request, check_data, processing_start_time)
                    if webhook_sent:
                        logger.info("‚úÖ [CHECK_QUANTITY] Successfully processed and sent webhook")

        # Continue with existing webhook processing...
        # ... rest of method unchanged ...

    except Exception as e:
        logger.error(f"‚ùå [BACKEND_ROUTING] Failed: {e}")
```

## üìã Implementation Checklist

### ‚úÖ Phase 1: Models & Enums (Priority: HIGH)
- [ ] Update `ChatIntent` enum v·ªõi 2 intents m·ªõi
- [ ] T·∫°o file `order_models.py` v·ªõi c√°c model classes
- [ ] Update import statements trong service files

### ‚úÖ Phase 2: AI Prompt Enhancement (Priority: HIGH)
- [ ] Update system prompt h·ªó tr·ª£ 7 intents
- [ ] Th√™m intent detection patterns cho UPDATE_ORDER & CHECK_QUANTITY
- [ ] Update prompt instructions cho t·ª´ng intent workflow

### ‚úÖ Phase 3: Service Methods (Priority: HIGH)
- [ ] Implement order update methods (4 methods)
- [ ] Implement quantity check methods (3 methods)
- [ ] Add validation & error handling
- [ ] Add comprehensive logging

### ‚úÖ Phase 4: Integration (Priority: MEDIUM)
- [ ] Update `_send_response_to_backend()` method
- [ ] Add intent routing logic
- [ ] Test integration v·ªõi existing PLACE_ORDER flow

### ‚úÖ Phase 5: Testing (Priority: MEDIUM)
- [ ] Unit tests cho new methods
- [ ] Integration tests cho complete flows
- [ ] Manual testing v·ªõi real conversations
- [ ] Error scenario testing

## üîó Backend Requirements

### **Required Webhook Endpoints**
Backend c·∫ßn implement 2 endpoints m·ªõi:

```
PUT /api/webhooks/orders/{orderCode}/ai
- Update existing order
- Validate order exists
- Send notification emails

POST /api/webhooks/orders/check-quantity/ai
- Process quantity check request
- Check inventory/availability
- Send result via email/SMS
```

### **Response Formats Expected**
```json
// Update Order Response
{
  "success": true,
  "message": "Order updated successfully",
  "data": {
    "orderCode": "ORD20250817001",
    "updatedFields": ["products", "delivery"],
    "notifications": {
      "customerEmailSent": true
    }
  }
}

// Quantity Check Response
{
  "success": true,
  "message": "Quantity check request received",
  "data": {
    "checkId": "CHK20250817001",
    "estimatedResponseTime": "2-4 hours",
    "notificationMethod": "email"
  }
}
```

## üìä Expected User Flows

### **UPDATE_ORDER Flow**
```
User: "T√¥i mu·ªën thay ƒë·ªïi ƒë∆°n h√†ng ORD20250817001"
AI: "Cho t√¥i bi·∫øt b·∫°n mu·ªën thay ƒë·ªïi g√¨ trong ƒë∆°n h√†ng?"
User: "Thay ƒë·ªïi s·ªë l∆∞·ª£ng t·ª´ 2 th√†nh 5 s·∫£n ph·∫©m"
AI: "X√°c nh·∫≠n thay ƒë·ªïi: ORD20250817001 - TƒÉng s·ªë l∆∞·ª£ng t·ª´ 2 l√™n 5. ƒê·ªìng √Ω?"
User: "ƒê·ªìng √Ω"
AI: "ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng! Email x√°c nh·∫≠n ƒë√£ ƒë∆∞·ª£c g·ª≠i."
‚Üí Webhook sent to PUT /api/webhooks/orders/ORD20250817001/ai
```

### **CHECK_QUANTITY Flow**
```
User: "Ki·ªÉm tra t·ªìn kho s·∫£n ph·∫©m ABC"
AI: "B·∫°n c·∫ßn ki·ªÉm tra s·ªë l∆∞·ª£ng bao nhi√™u s·∫£n ph·∫©m ABC?"
User: "C·∫ßn 100 c√°i"
AI: "ƒê·ªÉ ki·ªÉm tra, t√¥i c·∫ßn th√¥ng tin li√™n h·ªá. Cho t√¥i t√™n v√† email/sdt?"
User: "T√™n Nguy·ªÖn A, email test@email.com"
AI: "X√°c nh·∫≠n: Ki·ªÉm tra 100 s·∫£n ph·∫©m ABC, th√¥ng b√°o qua test@email.com?"
User: "ƒê·ªìng √Ω"
AI: "Y√™u c·∫ßu ƒë√£ ƒë∆∞·ª£c g·ª≠i! Ch√∫ng t√¥i s·∫Ω ki·ªÉm tra v√† th√¥ng b√°o trong 2-4h."
‚Üí Webhook sent to POST /api/webhooks/orders/check-quantity/ai
```

## üöÄ Next Steps

1. **Review & Approval**: Technical design review v·ªõi team
2. **Backend Coordination**: ƒê·∫£m b·∫£o Backend ready v·ªõi endpoints
3. **Implementation Order**:
   - Phase 1 ‚Üí Phase 2 ‚Üí Phase 3 ‚Üí Phase 4 ‚Üí Phase 5
4. **Testing Strategy**: Parallel testing v·ªõi backend development
5. **Documentation**: Update API docs v√† user guides

---

**üìù Implementation Priority**: HIGH - Critical for complete order management system
**üïê Estimated Timeline**: 2-3 weeks full implementation
**üë• Dependencies**: Backend webhook endpoints development

*Document created: 18/08/2025 - Implementation Analysis Complete*
