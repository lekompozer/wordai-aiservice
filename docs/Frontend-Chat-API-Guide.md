# Frontend Chat API Integration Guide
# H∆∞·ªõng D·∫´n T√≠ch H·ª£p API Chat Cho Frontend

## üìã T·ªïng Quan

T√†i li·ªáu n√†y h∆∞·ªõng d·∫´n Frontend t√≠ch h·ª£p v·ªõi API Chat Streaming c·ªßa h·ªá th·ªëng AI Agent.

## üöÄ API Endpoint

### **POST** `/api/unified/chat-stream`

- **URL**: `https://api.agent8x.io.vn/api/unified/chat-stream`
- **Method**: `POST`
- **Content-Type**: `application/json`
- **Response**: `text/event-stream` (Server-Sent Events)

## üìã Request Format

### Headers
```http
Content-Type: application/json
X-Company-ID: {company_id}  # Optional, c√≥ th·ªÉ g·ª≠i trong body
```

### Request Body
```json
{
  "message": "T√¥i mu·ªën t√¨m hi·ªÉu v·ªÅ l√£i su·∫•t vay",
  "company_id": "comp_123456",
  "industry": "banking",
  "language": "vietnamese",
  "user_info": {
    "user_id": "user_123",
    "name": "Nguy·ªÖn VƒÉn A",
    "email": "user@example.com",
    "source": "web_device"
  },
  "session_id": "session_abc123",  # Optional - h·ªá th·ªëng s·∫Ω t·ª± t·∫°o n·∫øu kh√¥ng c√≥
  "context": {
    "page_url": "https://example.com/banking",
    "user_agent": "Mozilla/5.0...",
    "disable_webhooks": false
  }
}
```

### Required Fields
- `message` (string): Tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng
- `company_id` (string): ID c√¥ng ty
- `industry` (enum): Ng√†nh ngh·ªÅ - `banking`, `insurance`, `restaurant`, `hotel`, `retail`, `fashion`, `industrial`, `healthcare`, `education`, `other`
- `user_info.user_id` (string): ID ng∆∞·ªùi d√πng
- `user_info.source` (enum): Ngu·ªìn truy c·∫≠p - `web_device`, `facebook_messenger`, `whatsapp`, `zalo`, `instagram`, `website_plugin`

### Optional Fields
- `language` (enum): `vietnamese`, `english`, `auto_detect` (default: `auto_detect`)
- `session_id` (string): ID phi√™n chat - h·ªá th·ªëng s·∫Ω t·ª± t·∫°o n·∫øu kh√¥ng c√≥
- `user_info.name` (string): T√™n ng∆∞·ªùi d√πng
- `user_info.email` (string): Email ng∆∞·ªùi d√πng
- `context` (object): Th√¥ng tin ng·ªØ c·∫£nh b·ªï sung

## üì° Response Format (Server-Sent Events)

Response ƒë∆∞·ª£c tr·∫£ v·ªÅ d∆∞·ªõi d·∫°ng **Server-Sent Events (SSE)** v·ªõi format:

```
data: {"type": "language", "language": "vietnamese"}

data: {"type": "intent", "intent": "information", "confidence": 0.85}

data: {"type": "content", "chunk": "Ch√†o b·∫°n! "}

data: {"type": "content", "chunk": "T√¥i c√≥ th·ªÉ "}

data: {"type": "content", "chunk": "gi√∫p b·∫°n t√¨m hi·ªÉu "}

data: {"type": "content", "chunk": "v·ªÅ l√£i su·∫•t vay ng√¢n h√†ng."}

data: {"type": "done", "session_id": "session_abc123", "conversation_id": "conv_xyz789"}
```

### Event Types

| Type | Description | Data Fields |
|------|-------------|-------------|
| `language` | K·∫øt qu·∫£ ph√°t hi·ªán ng√¥n ng·ªØ | `language` |
| `intent` | K·∫øt qu·∫£ ph√°t hi·ªán √Ω ƒë·ªãnh | `intent`, `confidence` |
| `content` | T·ª´ng ph·∫ßn n·ªôi dung tr·∫£ l·ªùi | `chunk` |
| `done` | T√≠n hi·ªáu ho√†n th√†nh | `session_id`, `conversation_id` |
| `error` | Th√¥ng b√°o l·ªói | `error`, `message` |

## üíª JavaScript Implementation

### 1. Basic Fetch with EventSource

```javascript
async function sendChatMessage(message, companyId, userId) {
  const response = await fetch('/api/unified/chat-stream', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Company-ID': companyId
    },
    body: JSON.stringify({
      message: message,
      company_id: companyId,
      industry: 'banking',
      language: 'auto_detect',
      user_info: {
        user_id: userId,
        source: 'web_device'
      }
    })
  });

  // ƒê·ªçc stream response
  const reader = response.body.getReader();
  let result = '';

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    const chunk = new TextDecoder().decode(value);
    const lines = chunk.split('\n');

    for (const line of lines) {
      if (line.startsWith('data: ')) {
        const data = JSON.parse(line.slice(6));
        handleStreamEvent(data);
      }
    }
  }
}

function handleStreamEvent(data) {
  switch (data.type) {
    case 'language':
      console.log('Detected language:', data.language);
      break;
    case 'intent':
      console.log('Detected intent:', data.intent, 'confidence:', data.confidence);
      break;
    case 'content':
      // Hi·ªÉn th·ªã t·ª´ng chunk n·ªôi dung
      appendToChat(data.chunk);
      break;
    case 'done':
      console.log('Chat completed:', data.session_id);
      break;
    case 'error':
      console.error('Chat error:', data.error);
      break;
  }
}
```

### 2. React Implementation

```jsx
import React, { useState, useCallback } from 'react';

const ChatComponent = ({ companyId, userId }) => {
  const [messages, setMessages] = useState([]);
  const [currentMessage, setCurrentMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const sendMessage = useCallback(async (message) => {
    if (!message.trim()) return;

    // Th√™m tin nh·∫Øn user v√†o chat
    setMessages(prev => [...prev, { type: 'user', content: message }]);
    setCurrentMessage('');
    setIsLoading(true);

    try {
      const response = await fetch('/api/unified/chat-stream', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Company-ID': companyId
        },
        body: JSON.stringify({
          message,
          company_id: companyId,
          industry: 'banking',
          user_info: {
            user_id: userId,
            source: 'web_device'
          }
        })
      });

      const reader = response.body.getReader();
      let aiResponse = '';

      // T·∫°o placeholder cho AI response
      setMessages(prev => [...prev, { type: 'ai', content: '', isStreaming: true }]);

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = new TextDecoder().decode(value);
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.slice(6));
            
            if (data.type === 'content') {
              aiResponse += data.chunk;
              // C·∫≠p nh·∫≠t real-time
              setMessages(prev => {
                const newMessages = [...prev];
                const lastMessage = newMessages[newMessages.length - 1];
                if (lastMessage.type === 'ai') {
                  lastMessage.content = aiResponse;
                }
                return newMessages;
              });
            } else if (data.type === 'done') {
              // Ho√†n th√†nh streaming
              setMessages(prev => {
                const newMessages = [...prev];
                const lastMessage = newMessages[newMessages.length - 1];
                if (lastMessage.type === 'ai') {
                  lastMessage.isStreaming = false;
                }
                return newMessages;
              });
            }
          }
        }
      }
    } catch (error) {
      console.error('Chat error:', error);
      setMessages(prev => [...prev, { 
        type: 'error', 
        content: 'ƒê√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.' 
      }]);
    } finally {
      setIsLoading(false);
    }
  }, [companyId, userId]);

  return (
    <div className="chat-container">
      <div className="messages">
        {messages.map((msg, index) => (
          <div key={index} className={`message ${msg.type}`}>
            {msg.content}
            {msg.isStreaming && <span className="cursor">|</span>}
          </div>
        ))}
      </div>
      
      <div className="input-container">
        <input
          type="text"
          value={currentMessage}
          onChange={(e) => setCurrentMessage(e.target.value)}
          onKeyPress={(e) => e.key === 'Enter' && sendMessage(currentMessage)}
          disabled={isLoading}
          placeholder="Nh·∫≠p tin nh·∫Øn..."
        />
        <button 
          onClick={() => sendMessage(currentMessage)}
          disabled={isLoading || !currentMessage.trim()}
        >
          G·ª≠i
        </button>
      </div>
    </div>
  );
};
```

### 3. Vue.js Implementation

```vue
<template>
  <div class="chat-container">
    <div class="messages">
      <div 
        v-for="(message, index) in messages" 
        :key="index" 
        :class="`message ${message.type}`"
      >
        {{ message.content }}
        <span v-if="message.isStreaming" class="cursor">|</span>
      </div>
    </div>
    
    <div class="input-container">
      <input
        v-model="currentMessage"
        @keyup.enter="sendMessage"
        :disabled="isLoading"
        placeholder="Nh·∫≠p tin nh·∫Øn..."
      />
      <button 
        @click="sendMessage"
        :disabled="isLoading || !currentMessage.trim()"
      >
        G·ª≠i
      </button>
    </div>
  </div>
</template>

<script>
export default {
  props: ['companyId', 'userId'],
  data() {
    return {
      messages: [],
      currentMessage: '',
      isLoading: false
    }
  },
  methods: {
    async sendMessage() {
      if (!this.currentMessage.trim()) return;

      // Th√™m tin nh·∫Øn user
      this.messages.push({ 
        type: 'user', 
        content: this.currentMessage 
      });

      const message = this.currentMessage;
      this.currentMessage = '';
      this.isLoading = true;

      try {
        const response = await fetch('/api/unified/chat-stream', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Company-ID': this.companyId
          },
          body: JSON.stringify({
            message,
            company_id: this.companyId,
            industry: 'banking',
            user_info: {
              user_id: this.userId,
              source: 'web_device'
            }
          })
        });

        const reader = response.body.getReader();
        let aiResponse = '';

        // Th√™m placeholder cho AI response
        this.messages.push({ 
          type: 'ai', 
          content: '', 
          isStreaming: true 
        });

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = new TextDecoder().decode(value);
          const lines = chunk.split('\n');

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = JSON.parse(line.slice(6));
              
              if (data.type === 'content') {
                aiResponse += data.chunk;
                const lastMessage = this.messages[this.messages.length - 1];
                lastMessage.content = aiResponse;
              } else if (data.type === 'done') {
                const lastMessage = this.messages[this.messages.length - 1];
                lastMessage.isStreaming = false;
              }
            }
          }
        }
      } catch (error) {
        console.error('Chat error:', error);
        this.messages.push({ 
          type: 'error', 
          content: 'ƒê√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i.' 
        });
      } finally {
        this.isLoading = false;
      }
    }
  }
}
</script>
```

## üé® CSS Styling

```css
.chat-container {
  max-width: 600px;
  margin: 0 auto;
  border: 1px solid #ddd;
  border-radius: 8px;
  overflow: hidden;
}

.messages {
  height: 400px;
  overflow-y: auto;
  padding: 16px;
  background: #f9f9f9;
}

.message {
  margin-bottom: 12px;
  padding: 8px 12px;
  border-radius: 8px;
  max-width: 80%;
}

.message.user {
  background: #007bff;
  color: white;
  margin-left: auto;
  text-align: right;
}

.message.ai {
  background: white;
  border: 1px solid #ddd;
}

.message.error {
  background: #dc3545;
  color: white;
}

.cursor {
  animation: blink 1s infinite;
  font-weight: bold;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

.input-container {
  display: flex;
  padding: 16px;
  background: white;
  border-top: 1px solid #ddd;
}

.input-container input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin-right: 8px;
}

.input-container button {
  padding: 8px 16px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.input-container button:disabled {
  background: #ccc;
  cursor: not-allowed;
}
```

## üîç Testing

### Test v·ªõi cURL
```bash
curl -X POST https://api.agent8x.io.vn/api/unified/chat-stream \
  -H "Content-Type: application/json" \
  -H "X-Company-ID: comp_123456" \
  -d '{
    "message": "T√¥i mu·ªën t√¨m hi·ªÉu v·ªÅ l√£i su·∫•t vay",
    "company_id": "comp_123456",
    "industry": "banking",
    "user_info": {
      "user_id": "test_user",
      "source": "web_device"
    }
  }'
```

## üìù Best Practices

1. **Session Management**: Lu√¥n l∆∞u tr·ªØ `session_id` ƒë·ªÉ duy tr√¨ ng·ªØ c·∫£nh cu·ªôc h·ªôi tho·∫°i
2. **Error Handling**: X·ª≠ l√Ω c√°c l·ªói m·∫°ng v√† server m·ªôt c√°ch graceful
3. **Loading States**: Hi·ªÉn th·ªã tr·∫°ng th√°i loading khi ƒëang stream
4. **Rate Limiting**: Tr√°nh g·ª≠i qu√° nhi·ªÅu request li√™n ti·∫øp
5. **User Experience**: Hi·ªÉn th·ªã typing indicator v√† streaming effect

## üêõ Common Issues

1. **CORS Error**: ƒê·∫£m b·∫£o domain ƒë∆∞·ª£c whitelist ·ªü server
2. **Network Timeout**: Th√™m timeout handling cho c√°c request d√†i
3. **Memory Leaks**: ƒê√≥ng c√°c stream reader khi component unmount
4. **Special Characters**: ƒê·∫£m b·∫£o UTF-8 encoding cho tin nh·∫Øn ti·∫øng Vi·ªát

## üìû Support

N·∫øu c√≥ v·∫•n ƒë·ªÅ trong qu√° tr√¨nh t√≠ch h·ª£p, vui l√≤ng li√™n h·ªá:
- Email: support@agent8x.io.vn
- Documentation: https://docs.agent8x.io.vn
