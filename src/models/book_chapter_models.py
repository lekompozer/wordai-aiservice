"""
Pydantic Models for Guide Chapters
Phase 1: Chapter organization and nested structure
Phase 2: Multi-format content support (PDF pages, Image pages)
"""

from pydantic import BaseModel, Field, validator
from typing import Optional, List, Dict, Any, Literal
from datetime import datetime
from enum import Enum

# Import BackgroundConfig for type hints
try:
    from src.models.book_background_models import BackgroundConfig
except ImportError:
    BackgroundConfig = Any  # Fallback for circular import


# ═══════════════════════════════════════════════════════════════════════
# PHASE 2: Multi-format Content Models (PDF Pages, Image Pages)
# ═══════════════════════════════════════════════════════════════════════


class ContentSource(str, Enum):
    """Chapter content source types"""

    INLINE = "inline"  # HTML/JSON content
    PDF_PAGES = "pdf_pages"  # PDF → pages array with backgrounds
    IMAGE_PAGES = "image_pages"  # Images → pages array (manga/comics)


class ElementType(str, Enum):
    """Page element types for overlays"""

    # PDF mode elements
    HIGHLIGHT = "highlight"
    TEXT = "text"
    SHAPE = "shape"
    IMAGE = "image"
    VIDEO = "video"  # Video embed with position
    ARROW = "arrow"
    UNDERLINE = "underline"
    STRIKETHROUGH = "strikethrough"
    NOTE = "note"  # Rectangular note/comment area with text

    # Manga mode elements
    SPEECH_BUBBLE = "speech_bubble"
    SOUND_EFFECT = "sound_effect"
    ANNOTATION = "annotation"
    PANEL_BORDER = "panel_border"


class PageElement(BaseModel):
    """
    Element overlay on page background

    Element Types & Required Fields:
    - TEXT: x, y, content, font_size, color
    - IMAGE: x, y, width, height, src
    - VIDEO: x, y, width, height, src (video URL)
    - NOTE: x, y, width, height, content (rectangular note/comment area)
    - HIGHLIGHT: x, y, width, height, color, opacity
    - SHAPE: x, y, width, height, color, style (rectangle/circle)
    - ARROW: x, y, width, height, color
    - UNDERLINE: x, y, width, color
    - STRIKETHROUGH: x, y, width, color
    - SPEECH_BUBBLE: x, y, width, height, content, style
    - SOUND_EFFECT: x, y, content, font_size
    - ANNOTATION: x, y, content
    - PANEL_BORDER: x, y, width, height, color
    """

    id: str = Field(..., description="Unique element ID (generated by frontend)")
    type: ElementType = Field(..., description="Element type")
    x: float = Field(..., description="X position in pixels (top-left corner)")
    y: float = Field(..., description="Y position in pixels (top-left corner)")
    width: Optional[float] = Field(
        None,
        description="Width in pixels (required for image/video/note/highlight/shape/panel)",
    )
    height: Optional[float] = Field(
        None,
        description="Height in pixels (required for image/video/note/highlight/shape/panel)",
    )
    z_index: int = Field(default=1, ge=0, description="Layer order (0=bottom)")

    # Type-specific properties (optional, depends on element type)
    color: Optional[str] = Field(None, description="Color (CSS format: #hex or rgba())")
    content: Optional[str] = Field(
        None,
        description="Text content (for text/note/annotation/speech_bubble/sound_effect)",
    )
    font_size: Optional[int] = Field(
        None, ge=8, le=72, description="Font size in pixels (8-72px)"
    )
    font_family: Optional[str] = Field(None, description="Font family name")
    src: Optional[str] = Field(
        None,
        description="Media URL (for image/video types) - can be R2 CDN or external URL",
    )
    style: Optional[str] = Field(
        None,
        description="Style variant (e.g., 'round', 'square' for speech bubbles; 'rectangle', 'circle' for shapes)",
    )
    opacity: Optional[float] = Field(
        None, ge=0.0, le=1.0, description="Opacity (0.0=transparent, 1.0=opaque)"
    )


class PageContent(BaseModel):
    """Single page with background image and overlay elements"""

    page_number: int = Field(..., ge=1, description="Page number (1-indexed)")
    background_url: str = Field(..., description="R2 CDN URL for background image")
    width: int = Field(..., ge=1, description="Page width in pixels")
    height: int = Field(..., ge=1, description="Page height in pixels")
    elements: List[PageElement] = Field(
        default_factory=list, description="Overlay elements on this page"
    )


class MangaMetadata(BaseModel):
    """Manga-specific metadata (for image_pages mode)"""

    reading_direction: Literal["left-to-right", "right-to-left"] = Field(
        default="right-to-left",
        description="Reading direction (manga is typically RTL)",
    )
    is_colored: bool = Field(default=False, description="Colored or black & white")
    artist: Optional[str] = Field(
        None, max_length=200, description="Artist/Author name"
    )
    genre: Optional[str] = Field(
        None, max_length=100, description="Genre (Action, Romance, etc.)"
    )


class ChapterCreatePDFPages(BaseModel):
    """Create chapter from PDF file (pdf_pages mode)"""

    file_id: str = Field(..., description="Existing PDF file ID from studyhub_files")
    title: str = Field(..., min_length=1, max_length=200, description="Chapter title")
    slug: Optional[str] = Field(
        None,
        max_length=200,
        description="Chapter URL slug (auto-generated if not provided)",
    )
    parent_id: Optional[str] = Field(None, description="Parent chapter ID for nesting")
    order_index: int = Field(
        default=0, ge=0, description="Display order at current level"
    )
    is_published: bool = Field(default=True, description="Published status")
    is_preview_free: bool = Field(default=False, description="Allow free preview")


class ChapterCreateImagePages(BaseModel):
    """Create chapter from image files (image_pages mode - manga/comics)"""

    file_ids: List[str] = Field(
        ..., min_items=1, description="List of image file IDs from studyhub_files"
    )
    title: str = Field(..., min_length=1, max_length=200, description="Chapter title")
    slug: Optional[str] = Field(None, max_length=200, description="Chapter URL slug")
    parent_id: Optional[str] = Field(None, description="Parent chapter ID for nesting")
    order_index: int = Field(default=0, ge=0, description="Display order")
    is_published: bool = Field(default=True, description="Published status")
    is_preview_free: bool = Field(default=False, description="Allow free preview")
    manga_metadata: Optional[MangaMetadata] = Field(
        None, description="Manga-specific settings"
    )


class ChapterCreateFromUploadedImages(BaseModel):
    """Create chapter from previously uploaded images (simplified flow)"""

    chapter_id: str = Field(
        ...,
        description="Chapter ID from upload-images endpoint (images already in R2)",
    )
    title: str = Field(..., min_length=1, max_length=200, description="Chapter title")
    slug: Optional[str] = Field(
        None,
        max_length=200,
        description="Chapter URL slug (auto-generated if not provided)",
    )
    parent_id: Optional[str] = Field(None, description="Parent chapter ID for nesting")
    order_index: int = Field(
        default=0, ge=0, description="Display order at current level"
    )
    is_published: bool = Field(default=True, description="Published status")
    is_preview_free: bool = Field(default=False, description="Allow free preview")
    manga_metadata: Optional[MangaMetadata] = Field(
        None, description="Manga-specific settings"
    )


class PageElementsUpdate(BaseModel):
    """Update elements for a specific page (partial update - elements only)"""

    page_number: int = Field(..., ge=1, description="Page number to update (1-indexed)")
    elements: List[PageElement] = Field(
        default_factory=list,
        description="Updated elements array for this page (replaces existing)",
    )


class ChapterPagesUpdate(BaseModel):
    """Update page elements (add highlights, notes, etc.)"""

    pages: List[PageElementsUpdate] = Field(
        ...,
        min_length=1,
        description="Pages with updated elements (only include pages that changed)",
    )


class PageBackgroundUpdate(BaseModel):
    """Update background image for a specific page"""

    background_url: str = Field(
        ..., description="New background image URL (R2 CDN or external)"
    )
    width: Optional[int] = Field(
        None, ge=1, description="New page width (optional, auto-detect if not provided)"
    )
    height: Optional[int] = Field(
        None,
        ge=1,
        description="New page height (optional, auto-detect if not provided)",
    )
    keep_elements: bool = Field(
        default=True,
        description="Keep existing elements when changing background (default: true)",
    )


class PageReorderRequest(BaseModel):
    """Request to reorder pages - supports 2 formats"""

    page_order: Optional[List[int]] = Field(
        None,
        description="New page order as array (e.g., [3, 1, 2, 4] means page 3 becomes position 1)",
    )
    page_mapping: Optional[Dict[str, int]] = Field(
        None,
        description='Page number mapping as dict (e.g., {"1": 2, "2": 1} means page 1 → position 2)',
    )

    @validator("page_mapping", "page_order", pre=True, always=True)
    def validate_one_format(cls, v, values, field):
        """Ensure exactly one format is provided"""
        page_order = values.get("page_order")
        page_mapping = v if field.name == "page_mapping" else values.get("page_mapping")

        # At root validator time, check both are not None
        if field.name == "page_mapping":
            if page_order is not None and page_mapping is not None:
                raise ValueError(
                    "Provide either 'page_order' OR 'page_mapping', not both"
                )
            if page_order is None and page_mapping is None:
                raise ValueError("Must provide either 'page_order' or 'page_mapping'")

        return v


# ═══════════════════════════════════════════════════════════════════════
# EXISTING MODELS (Phase 1)
# ═══════════════════════════════════════════════════════════════════════


class ChapterCreate(BaseModel):
    """Request model to add chapter to guide"""

    title: str = Field(..., min_length=1, max_length=200, description="Chapter title")
    slug: Optional[str] = Field(
        None,
        max_length=200,
        description="Chapter URL slug (will be auto-normalized to a-z0-9- format)",
    )
    document_id: Optional[str] = Field(
        None,
        description="Document ID to use as chapter content (can create empty chapter)",
    )
    parent_id: Optional[str] = Field(
        None, description="Parent chapter ID for nesting (null for root)"
    )
    order_index: int = Field(
        default=0, ge=0, description="Display order at current level"
    )
    order: Optional[int] = Field(
        None, ge=0, description="Alias for order_index (for backward compatibility)"
    )
    is_published: bool = Field(default=True, description="Published status")
    is_preview_free: bool = Field(
        default=False,
        description="Allow free preview on Community Books (no purchase required)",
    )

    # Content fields (for inline chapters)
    content_source: Optional[str] = Field(
        default="inline",
        description="Content storage: 'inline' (in chapter) or 'document' (linked document)",
    )
    content_html: Optional[str] = Field(
        default=None, description="Chapter content in HTML format (for inline chapters)"
    )
    content_json: Optional[Dict[str, Any]] = Field(
        default=None, description="Chapter content in JSON format (TipTap editor)"
    )

    @property
    def get_order_index(self) -> int:
        """Get order index, preferring order_index but falling back to order"""
        return (
            self.order
            if self.order is not None and self.order_index == 0
            else self.order_index
        )


class ChapterUpdate(BaseModel):
    """Request model to update chapter"""

    title: Optional[str] = Field(None, min_length=1, max_length=200)
    slug: Optional[str] = Field(
        None, max_length=200, description="Chapter URL slug (will be auto-normalized)"
    )
    description: Optional[str] = Field(
        None, max_length=5000, description="Chapter description (for SEO and preview)"
    )
    parent_id: Optional[str] = None
    order_index: Optional[int] = Field(None, ge=0)
    is_published: Optional[bool] = None
    is_preview_free: Optional[bool] = Field(
        None, description="Allow free preview on Community Books"
    )


class ChapterContentUpdate(BaseModel):
    """Request model to update chapter content"""

    content_html: str = Field(..., description="Chapter content in HTML format")
    content_json: Optional[Dict[str, Any]] = Field(
        default=None, description="Chapter content in JSON format (TipTap editor)"
    )


class ConvertDocumentToChapterRequest(BaseModel):
    """Request to convert document to chapter"""

    book_id: str = Field(..., description="Target book ID")
    title: Optional[str] = Field(
        None, description="Chapter title (uses document name if not provided)"
    )
    order_index: int = Field(default=0, ge=0, description="Position in chapter list")
    parent_id: Optional[str] = Field(None, description="Parent chapter for nesting")
    copy_content: bool = Field(
        default=True,
        description="If True, copy content to chapter (inline). If False, link to document.",
    )


class ChapterReorder(BaseModel):
    """Request model for single chapter reorder"""

    chapter_id: str
    parent_id: Optional[str] = None
    order_index: int = Field(default=0, ge=0)


class ChapterReorderBulk(BaseModel):
    """Bulk reorder request"""

    updates: List[ChapterReorder]


class ChapterBulkUpdateItem(BaseModel):
    """Single chapter update in bulk operation"""

    chapter_id: str = Field(..., description="Chapter ID to update")
    title: Optional[str] = Field(
        None, min_length=1, max_length=200, description="New chapter title"
    )
    slug: Optional[str] = Field(
        None, pattern="^[a-z0-9-]+$", description="New chapter slug"
    )
    description: Optional[str] = Field(
        None, max_length=5000, description="New chapter description"
    )
    parent_id: Optional[str] = Field(
        None, description="New parent chapter ID (null for root)"
    )
    order_index: Optional[int] = Field(
        None, ge=0, description="New position at current level"
    )


class BookInfoUpdate(BaseModel):
    """Book information update (title, description, slug, and cover)"""

    title: Optional[str] = Field(
        None, min_length=1, max_length=200, description="New book title"
    )
    description: Optional[str] = Field(
        None, max_length=5000, description="New book description"
    )
    slug: Optional[str] = Field(
        None, pattern="^[a-z0-9-]+$", description="New book slug (URL-friendly)"
    )
    cover_image_url: Optional[str] = Field(None, description="New book cover image URL")


class ChapterBulkUpdate(BaseModel):
    """Bulk update chapters (title, slug, order, parent) and optionally book info"""

    updates: List[ChapterBulkUpdateItem] = Field(
        ..., min_length=1, description="List of chapter updates"
    )
    book_info: Optional[BookInfoUpdate] = Field(
        None, description="Optional book title and cover update"
    )


class ChapterResponse(BaseModel):
    """Response model for chapter"""

    chapter_id: str
    book_id: str
    title: str
    slug: str
    description: Optional[str] = Field(
        default=None, description="Chapter description (for SEO and preview)"
    )
    document_id: Optional[str] = None
    parent_id: Optional[str] = None
    order_index: int
    depth: int
    is_published: bool
    is_preview_free: bool = Field(
        default=False, description="Free preview on Community Books"
    )

    # Background Configuration (NEW)
    use_book_background: bool = Field(
        default=True,
        description="If true, inherit background from book. If false, use chapter's own background_config",
    )
    background_config: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Chapter's own background config (only used if use_book_background=false)",
    )

    # Audio Configuration (NEW)
    audio_config: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Chapter's audio narration config (owner-provided)",
    )

    # Multi-Language Support (NEW)
    default_language: str = Field(
        default="vi", description="Default language of the chapter"
    )
    current_language: Optional[str] = Field(
        default=None, description="Current language being viewed"
    )
    available_languages: List[str] = Field(
        default_factory=lambda: ["vi"],
        description="List of available language codes",
    )
    translations: Optional[Dict[str, Any]] = Field(
        default_factory=dict,
        description="Translations: {lang_code: {title, description, content_html, ...}}",
    )
    background_translations: Optional[Dict[str, Any]] = Field(
        default_factory=dict,
        description="Custom backgrounds per language: {lang_code: background_config}",
    )
    audio_translations: Optional[Dict[str, Any]] = Field(
        default_factory=dict,
        description="Audio per language: {lang_code: {audio_url, voice_settings, ...}}",
    )

    created_at: datetime
    updated_at: datetime

    # Content fields (when loading chapter content)
    content: Optional[str] = Field(
        default=None,
        description="Chapter content in HTML format (alias for content_html)",
    )
    content_html: Optional[str] = Field(
        default=None,
        description="Chapter content in HTML format (from document or inline)",
    )
    content_json: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Chapter content in JSON format (TipTap editor format)",
    )
    document_name: Optional[str] = Field(
        default=None,
        description="Name of linked document (if content_source='document')",
    )


class ChapterTreeNode(BaseModel):
    """Chapter with nested children (tree structure)"""

    chapter_id: str
    title: str
    slug: str
    description: Optional[str] = Field(
        default=None, description="Chapter description (for SEO and preview)"
    )
    order_index: int
    depth: int
    is_published: bool
    document_id: Optional[str] = None
    children: List["ChapterTreeNode"] = []


# Enable forward references for recursive model
ChapterTreeNode.model_rebuild()


class ChapterListResponse(BaseModel):
    """Response for chapter listing"""

    chapters: List[ChapterTreeNode]
    total_chapters: int


class TogglePreviewRequest(BaseModel):
    """Request to toggle chapter preview status"""

    is_preview_free: bool = Field(
        description="Set to true to allow free preview on Community Books"
    )


class AudioVoiceSettings(BaseModel):
    """Voice settings for AI-generated audio"""

    voice_name: str = Field(..., description="Google Cloud TTS voice name")
    language_code: str = Field(..., description="Language code (e.g., en-US, vi-VN)")
    gender: Optional[str] = Field(
        None, description="Voice gender (MALE, FEMALE, NEUTRAL)"
    )
    speaking_rate: float = Field(
        1.0, ge=0.25, le=4.0, description="Speaking rate (0.25-4.0)"
    )
    pitch: float = Field(0.0, ge=-20.0, le=20.0, description="Voice pitch (-20 to +20)")
    volume_gain_db: float = Field(
        0.0, ge=-96.0, le=16.0, description="Volume gain in dB"
    )


class AudioConfig(BaseModel):
    """Audio configuration for chapter"""

    enabled: bool = Field(True, description="Audio available for this chapter")
    audio_url: str = Field(..., description="Public URL to audio file")
    audio_file_id: str = Field(..., description="Reference to library file")
    duration_seconds: int = Field(..., ge=0, description="Audio duration in seconds")
    file_size_bytes: int = Field(..., ge=0, description="Audio file size in bytes")
    format: str = Field("mp3", description="Audio format (mp3, wav, m4a, ogg)")
    source_type: str = Field(..., description="user_upload or ai_generated")
    voice_settings: Optional[AudioVoiceSettings] = Field(
        None, description="Voice settings for AI audio"
    )
    generated_at: Optional[datetime] = Field(
        None, description="When audio was generated"
    )
    generated_by_user_id: Optional[str] = Field(
        None, description="User who generated the audio"
    )
    generation_cost_points: Optional[int] = Field(
        None, description="Points spent on generation"
    )


class AudioUploadRequest(BaseModel):
    """Request to upload audio file"""

    language: Optional[str] = Field(
        None, description="Language code for translation audio"
    )
