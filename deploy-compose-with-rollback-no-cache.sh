#!/bin/bash

# ===================================================================================
# DOCKER-COMPOSE DEPLOYMENT WITH AUTOMATIC ROLLBACK (NO CACHE VERSION)
# ===================================================================================
# This script deploys using docker-compose.yml with safety mechanisms:
# 1. Tags images with Git commit hash for versioning
# 2. Saves current running version before deploying new version
# 3. Performs health checks on new deployment
# 4. Automatically rolls back to previous version if health check fails
#
# ‚ö†Ô∏è  NO CACHE VERSION: This will rebuild from scratch and reinstall all libraries
# Use this when:
# - You updated requirements.txt or package dependencies
# - You want a completely fresh build
# - You suspect cache corruption issues
#
# For faster deploys with cache, use: deploy-compose-with-rollback.sh
#
# PREREQUISITES:
# - Network "ai-chatbot-network" must exist (created by deploy-manual.sh)
# - .env file with all required credentials must exist
# ===================================================================================

set -e # Exit immediately if a command exits with a non-zero status

# --- DETECT DOCKER COMPOSE COMMAND ---
# Auto-detect whether to use 'docker-compose' (v1) or 'docker compose' (v2)
if command -v docker-compose &> /dev/null; then
    DOCKER_COMPOSE_CMD="docker-compose"
elif docker compose version &> /dev/null; then
    DOCKER_COMPOSE_CMD="docker compose"
else
    echo "‚ùå ERROR: Neither 'docker-compose' nor 'docker compose' command found!"
    echo "   Please install Docker Compose: https://docs.docker.com/compose/install/"
    exit 1
fi

echo "‚úÖ Using Docker Compose command: $DOCKER_COMPOSE_CMD"

# --- CONFIGURATION ---
APP_NAME="wordai-aiservice"
DOCKER_COMPOSE_FILE="docker-compose.yml"
SERVICE_NAME="ai-chatbot-rag"
HEALTH_CHECK_DELAY=60 # Seconds to wait before checking health
MAX_HEALTH_RETRIES=3  # Number of health check attempts
HEALTH_CHECK_INTERVAL=15 # Seconds between health check retries
DOCKER_HUB_USERNAME="${DOCKER_HUB_USERNAME:-lekompozer}"
NETWORK_NAME="ai-chatbot-network"

echo "üöÄ Starting Docker Compose deployment with rollback protection..."
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "‚ö†Ô∏è  NO CACHE MODE: This will rebuild everything from scratch"
echo "   ‚Ä¢ All Docker build cache will be ignored"
echo "   ‚Ä¢ All Python dependencies will be reinstalled"
echo "   ‚Ä¢ Build time will be significantly longer"
echo ""
echo "üí° For faster deploys with cache, use: ./deploy-compose-with-rollback.sh"
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

# --- 1. VERIFY PREREQUISITES ---
echo "üîç Verifying prerequisites..."

# Check if .env file exists
if [ ! -f .env ]; then
    echo "‚ùå ERROR: .env file not found!"
    echo "   Please create .env file with required credentials."
    exit 1
fi

# Check if network exists
if ! docker network ls | grep -q "$NETWORK_NAME"; then
    echo "‚ö†Ô∏è  Network '$NETWORK_NAME' does not exist. Creating it..."
    docker network create --driver bridge "$NETWORK_NAME"
    echo "‚úÖ Network created: $NETWORK_NAME"
else
    echo "‚úÖ Network '$NETWORK_NAME' exists"
fi

# Load environment variables
source .env
echo "‚úÖ Environment variables loaded from .env"

# --- 2. GIT VERSION CONTROL ---
echo ""
echo "üì¶ Preparing version information..."
git checkout main
git pull origin main

NEW_VERSION_TAG=$(git rev-parse --short HEAD)
echo "‚úÖ New version tag: $NEW_VERSION_TAG"

# --- 3. IDENTIFY CURRENT VERSION FOR ROLLBACK ---
echo ""
echo "üîç Identifying current running version for rollback..."

CURRENT_CONTAINER_ID=$(docker ps -q --filter "name=${SERVICE_NAME}")
PREVIOUS_VERSION_TAG=""

if [ -n "$CURRENT_CONTAINER_ID" ]; then
    PREVIOUS_VERSION_TAG=$(docker inspect --format='{{.Config.Image}}' $CURRENT_CONTAINER_ID 2>/dev/null | cut -d':' -f2)
    if [ -n "$PREVIOUS_VERSION_TAG" ]; then
        echo "‚úÖ Found currently running version: $PREVIOUS_VERSION_TAG"
        echo "   This will be used for rollback if deployment fails."
    else
        echo "‚ö†Ô∏è  Could not determine current version tag."
        echo "   Rollback may not be available."
    fi
else
    echo "‚ö†Ô∏è  No currently running container found."
    echo "   This appears to be a fresh deployment."
fi

# --- 4. BUILD NEW DOCKER IMAGE (NO CACHE) ---
echo ""
echo "üõ†Ô∏è  Building new Docker image (NO CACHE - Full rebuild)..."
echo "   Tag: $DOCKER_HUB_USERNAME/$APP_NAME:$NEW_VERSION_TAG"
echo "   ‚è±Ô∏è  This may take several minutes as all layers will be rebuilt..."

export IMAGE_TAG=$NEW_VERSION_TAG
export DOCKER_HUB_USERNAME=$DOCKER_HUB_USERNAME

# Build the image with --no-cache flag to force fresh build
DOCKER_BUILDKIT=1 docker build \
    --no-cache \
    --pull \
    -t "$DOCKER_HUB_USERNAME/$APP_NAME:$NEW_VERSION_TAG" \
    .

# Also tag as latest
docker tag "$DOCKER_HUB_USERNAME/$APP_NAME:$NEW_VERSION_TAG" "$DOCKER_HUB_USERNAME/$APP_NAME:latest"

echo "‚úÖ Image built and tagged successfully (no cache used)"

# --- 5. DEPLOY NEW VERSION ---
echo ""
echo "üöÄ Deploying new version with docker-compose..."
echo "   Version: $NEW_VERSION_TAG"

# Stop any standalone containers from deploy-manual.sh that might conflict
echo "üõë Checking for existing standalone containers..."
if docker ps -a --format '{{.Names}}' | grep -q "^mongodb$"; then
    echo "   Found standalone mongodb container, stopping it..."
    docker stop mongodb 2>/dev/null || true
    docker rm mongodb 2>/dev/null || true
    echo "   ‚úÖ Standalone mongodb container removed (data preserved in volume)"
fi

if docker ps -a --format '{{.Names}}' | grep -q "^redis-server$"; then
    echo "   Found standalone redis-server container, stopping it..."
    docker stop redis-server 2>/dev/null || true
    docker rm redis-server 2>/dev/null || true
    echo "   ‚úÖ Standalone redis-server container removed (data preserved in volume)"
fi

if docker ps -a --format '{{.Names}}' | grep -q "^ai-chatbot-rag$"; then
    echo "   Found standalone ai-chatbot-rag container, stopping it..."
    docker stop ai-chatbot-rag 2>/dev/null || true
    docker rm ai-chatbot-rag 2>/dev/null || true
    echo "   ‚úÖ Standalone ai-chatbot-rag container removed"
fi

# Stop current docker-compose services (if any)
echo "üõë Stopping docker-compose managed services..."
$DOCKER_COMPOSE_CMD -f $DOCKER_COMPOSE_FILE down --remove-orphans

# Start new services
echo "üöÄ Starting new services..."
$DOCKER_COMPOSE_CMD -f $DOCKER_COMPOSE_FILE up -d

echo "‚úÖ Services started"

# --- 5b. ENSURE MONGODB USER EXISTS ---
echo ""
echo "üîê Ensuring MongoDB application user exists..."
sleep 10  # Wait for MongoDB to be ready

# Check if app user exists, create if not
docker exec mongodb mongosh admin \
  --username "$MONGODB_ROOT_USERNAME" \
  --password "$MONGODB_ROOT_PASSWORD" \
  --eval "
    const userExists = db.getUser('$MONGODB_APP_USERNAME');
    if (!userExists) {
      db.createUser({
        user: '$MONGODB_APP_USERNAME',
        pwd: '$MONGODB_APP_PASSWORD',
        roles: [
          { role: 'readWrite', db: '$MONGODB_NAME' },
          { role: 'dbAdmin', db: '$MONGODB_NAME' }
        ]
      });
      print('‚úÖ Application user created');
    } else {
      print('‚ÑπÔ∏è  Application user already exists');
    }
  " 2>/dev/null || echo "‚ö†Ô∏è  Note: User may already exist or MongoDB is still starting"

echo "‚úÖ MongoDB user check completed"

# --- 5c. RUN E2EE MIGRATION SCRIPT (IF NEEDED) ---
echo ""
echo "üîê Checking E2EE keys migration status..."

# Check if migration is needed (using admin auth for reliability)
MIGRATION_NEEDED=$(docker exec mongodb mongosh "$MONGODB_NAME" \
  --username "$MONGODB_ROOT_USERNAME" \
  --password "$MONGODB_ROOT_PASSWORD" \
  --authenticationDatabase admin \
  --quiet \
  --eval "db.users.countDocuments({publicKey: {\$exists: true}, e2eeKeysMigrated: {\$ne: true}})" 2>/dev/null || echo "0")

if [ "$MIGRATION_NEEDED" -gt 0 ]; then
    echo "‚ö†Ô∏è  Found $MIGRATION_NEEDED users with old E2EE keys (24-word system)"
    echo "üöÄ Running migration to 12-word recovery system..."
    echo ""
    echo "üìã Migration will:"
    echo "   ‚Ä¢ Create backup of all E2EE keys"
    echo "   ‚Ä¢ Clear old keys (24-word system)"
    echo "   ‚Ä¢ Mark secret documents as unreadable"
    echo "   ‚Ä¢ Set migration flags for tracking"
    echo ""

    # Run migration script inside container with production environment
    # Script will auto-confirm in non-interactive mode (no stdin input needed)
    docker exec -e ENV=production $SERVICE_NAME python3 migrate_to_12_word_recovery.py

    MIGRATION_EXIT_CODE=$?

    if [ $MIGRATION_EXIT_CODE -eq 0 ]; then
        echo ""
        echo "‚úÖ E2EE keys migration completed successfully"
        echo ""
        echo "üìÇ Backup files created inside container:"
        docker exec $SERVICE_NAME ls -lh e2ee_keys_backup_*.json 2>/dev/null || echo "   (No backup files found)"
        echo ""
        echo "üí° To retrieve backup files:"
        echo "   docker cp $SERVICE_NAME:/app/e2ee_keys_backup_production_*.json ./backups/"
        echo ""
    else
        echo ""
        echo "‚ö†Ô∏è  Migration script exited with code: $MIGRATION_EXIT_CODE"
        echo "   Continuing deployment anyway..."
        echo ""
        echo "üîß Troubleshooting:"
        echo "   ‚Ä¢ Check migration logs: docker exec $SERVICE_NAME cat migration_log_*.json"
        echo "   ‚Ä¢ Run manually: docker exec -it $SERVICE_NAME python3 migrate_to_12_word_recovery.py"
        echo "   ‚Ä¢ Check MongoDB connection from container"
        echo ""
    fi
else
    echo "‚úÖ No E2EE migration needed"
    echo "   Reason: No users with old keys found"
    echo "   ‚Ä¢ Users already migrated: $(docker exec mongodb mongosh "$MONGODB_NAME" --username "$MONGODB_ROOT_USERNAME" --password "$MONGODB_ROOT_PASSWORD" --authenticationDatabase admin --quiet --eval "db.users.countDocuments({e2eeKeysMigrated: true})" 2>/dev/null || echo "N/A")"
    echo "   ‚Ä¢ Users with keys: $(docker exec mongodb mongosh "$MONGODB_NAME" --username "$MONGODB_ROOT_USERNAME" --password "$MONGODB_ROOT_PASSWORD" --authenticationDatabase admin --quiet --eval "db.users.countDocuments({publicKey: {\$exists: true}})" 2>/dev/null || echo "N/A")"
fi

# --- 6. HEALTH CHECK WITH RETRY ---
echo ""
echo "ü©∫ Performing health checks..."
echo "   Initial delay: ${HEALTH_CHECK_DELAY}s"
echo "   Max retries: $MAX_HEALTH_RETRIES"
echo "   Interval: ${HEALTH_CHECK_INTERVAL}s"

sleep $HEALTH_CHECK_DELAY

HEALTH_CHECK_PASSED=false
RETRY_COUNT=0

while [ $RETRY_COUNT -lt $MAX_HEALTH_RETRIES ]; do
    echo ""
    echo "üîç Health check attempt $((RETRY_COUNT + 1))/$MAX_HEALTH_RETRIES..."

    # Check if container is running
    NEW_CONTAINER_ID=$(docker ps -q --filter "name=${SERVICE_NAME}" 2>/dev/null)

    if [ -z "$NEW_CONTAINER_ID" ]; then
        echo "‚ùå Container is not running"
        RETRY_COUNT=$((RETRY_COUNT + 1))
        if [ $RETRY_COUNT -lt $MAX_HEALTH_RETRIES ]; then
            echo "‚è≥ Waiting ${HEALTH_CHECK_INTERVAL}s before retry..."
            sleep $HEALTH_CHECK_INTERVAL
        fi
        continue
    fi

    # Check container status
    CONTAINER_STATUS=$(docker inspect --format='{{.State.Status}}' $NEW_CONTAINER_ID 2>/dev/null)
    echo "   Container status: $CONTAINER_STATUS"

    if [ "$CONTAINER_STATUS" != "running" ]; then
        echo "‚ùå Container is not in 'running' state"
        RETRY_COUNT=$((RETRY_COUNT + 1))
        if [ $RETRY_COUNT -lt $MAX_HEALTH_RETRIES ]; then
            echo "‚è≥ Waiting ${HEALTH_CHECK_INTERVAL}s before retry..."
            sleep $HEALTH_CHECK_INTERVAL
        fi
        continue
    fi

    # Check HTTP health endpoint
    if curl -sf http://localhost:8000/health >/dev/null 2>&1; then
        echo "‚úÖ Health endpoint responding"
        HEALTH_CHECK_PASSED=true
        break
    else
        echo "‚ö†Ô∏è  Health endpoint not responding yet"
        RETRY_COUNT=$((RETRY_COUNT + 1))
        if [ $RETRY_COUNT -lt $MAX_HEALTH_RETRIES ]; then
            echo "‚è≥ Waiting ${HEALTH_CHECK_INTERVAL}s before retry..."
            sleep $HEALTH_CHECK_INTERVAL
        fi
    fi
done

# --- 7. DECISION: SUCCESS OR ROLLBACK ---
echo ""
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

if [ "$HEALTH_CHECK_PASSED" = true ]; then
    # ‚úÖ SUCCESS
    echo "‚úÖ DEPLOYMENT SUCCESSFUL!"
    echo ""
    echo "üéâ New version $NEW_VERSION_TAG is running and healthy"
    echo "   Built with NO CACHE - all dependencies freshly installed"
    echo ""
    echo "üìä Current Status:"
    $DOCKER_COMPOSE_CMD -f $DOCKER_COMPOSE_FILE ps
    echo ""
    echo "üåê Service URLs:"
    echo "   ‚Ä¢ API: http://localhost:8000"
    echo "   ‚Ä¢ Health: http://localhost:8000/health"
    echo "   ‚Ä¢ Docs: http://localhost:8000/docs"
    echo ""
    echo "üìã Useful Commands:"
    echo "   $DOCKER_COMPOSE_CMD -f $DOCKER_COMPOSE_FILE logs -f $SERVICE_NAME"
    echo "   $DOCKER_COMPOSE_CMD -f $DOCKER_COMPOSE_FILE ps"
    echo "   $DOCKER_COMPOSE_CMD -f $DOCKER_COMPOSE_FILE down"
    echo ""
    echo "üí° Next deploys can use cached version for speed:"
    echo "   ./deploy-compose-with-rollback.sh"

else
    # ‚ùå FAILURE - ROLLBACK
    echo "‚ùå DEPLOYMENT FAILED!"
    echo ""
    echo "üîç Diagnosis:"
    echo "   Health checks failed after $MAX_HEALTH_RETRIES attempts"
    echo ""
    echo "üìã Recent logs from failed container:"
    docker logs $SERVICE_NAME --tail=50 2>/dev/null || echo "   (Could not retrieve logs)"
    echo ""

    if [ -n "$PREVIOUS_VERSION_TAG" ] && [ "$PREVIOUS_VERSION_TAG" != "latest" ]; then
        echo "üîÑ INITIATING AUTOMATIC ROLLBACK..."
        echo "   Rolling back to version: $PREVIOUS_VERSION_TAG"

        # Stop failed deployment
        echo "üõë Stopping failed deployment..."
        $DOCKER_COMPOSE_CMD -f $DOCKER_COMPOSE_FILE down --remove-orphans

        # Set environment to previous version
        export IMAGE_TAG=$PREVIOUS_VERSION_TAG

        # Start previous version
        echo "üöÄ Starting previous version..."
        $DOCKER_COMPOSE_CMD -f $DOCKER_COMPOSE_FILE up -d

        # Quick health check on rolled-back version
        echo "ü©∫ Verifying rollback..."
        sleep 15

        if curl -sf http://localhost:8000/health >/dev/null 2>&1; then
            echo "‚úÖ ROLLBACK SUCCESSFUL!"
            echo ""
            echo "üéØ System restored to version: $PREVIOUS_VERSION_TAG"
            echo ""
            echo "‚ö†Ô∏è  Action Required:"
            echo "   ‚Ä¢ Review logs: docker logs $SERVICE_NAME --tail=100"
            echo "   ‚Ä¢ Fix issues in code or dependencies"
            echo "   ‚Ä¢ Check requirements.txt for conflicting packages"
            echo "   ‚Ä¢ Test locally before redeploying"
        else
            echo "‚ùå CRITICAL: ROLLBACK ALSO FAILED!"
            echo ""
            echo "üö® IMMEDIATE ACTION REQUIRED:"
            echo "   ‚Ä¢ System may be down"
            echo "   ‚Ä¢ Check logs: docker logs $SERVICE_NAME"
            echo "   ‚Ä¢ Manual intervention needed"
            echo "   ‚Ä¢ Consider running: ./deploy-manual.sh"
            exit 1
        fi
    else
        echo "‚ùå CRITICAL FAILURE: No previous version available for rollback"
        echo ""
        echo "üö® IMMEDIATE ACTION REQUIRED:"
        echo "   ‚Ä¢ System is down"
        echo "   ‚Ä¢ Review logs: docker logs $SERVICE_NAME --tail=100"
        echo "   ‚Ä¢ Fix issues and redeploy"
        echo "   ‚Ä¢ Or restore from backup manually"
        exit 1
    fi
fi

# Cleanup
unset IMAGE_TAG
unset DOCKER_HUB_USERNAME

echo ""
echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
echo "üèÅ Deployment script completed"
echo ""
echo "üíæ Build Cache Status: CLEARED (no-cache build)"
echo "   Next build will also be slow unless you use cached version"
